var canvas = document.querySelector("canvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var c = canvas.getContext("2d");

var holdingDownMouse = false;

var movesArray = [];
var drawPath = [];

var startRow = 1;
var startColumn = 1;
var endRow = 48;
var endColumn = 48;

var mode = "BFS";

var gridDimension = 50;

var verticalSpacing = innerHeight / gridDimension;
var horizontalSpacing = innerWidth / gridDimension;

var black = "#000000";
var green = "#00FF00";
var white = "#FFFFFF";
var red = "#FF0000";
var blue = "#0000FF";

var autoGeneratedMaze = true;

var isBlocked = new Array(gridDimension);
for (var i = 0; i < gridDimension; i++) {
  isBlocked[i] = new Array(gridDimension);
  for (var j = 0; j < gridDimension; j++) {
    isBlocked[i][j] = autoGeneratedMaze; // needs to be blocked for Prim's algo, unblocked for manual fill
  }
}

for (var i = 0; i < gridDimension; i++) {
  for (var j = 0; j < gridDimension; j++) {
    if (isBlocked[i][j]) {
      fillCell(xCellToPixel(i), yCellToPixel(j), black);
    }
    else {
      fillCell(xCellToPixel(i), yCellToPixel(j), white);
    }
  }
}

mazeGenerateMoves = [];

if (autoGeneratedMaze) { // randomized Prim's algorithm
  var unvisitedFrontier = []; // format: [frontierRow, frontierColumn, sourceRow, sourceColumn]
  var visited = new Array(gridDimension);
  for (var i = 0; i < gridDimension; i++) {
    visited[i] = new Array(gridDimension);
    for (var j = 0; j < gridDimension; j++) {
      visited[i][j] = false;
    }
  }
  isBlocked[endRow][endColumn] = false;
  visited[endRow][endColumn] = true;
  isBlocked[startRow][startColumn] = false;
  visited[startRow][startColumn] = true;
  neighbors = getNeighborCells(endRow, endColumn, 2); // due to implementation, need second neighbor
  for (var i = 0; i < neighbors.length; i++) {
    unvisitedFrontier.push([neighbors[i][0], neighbors[i][1], endRow, endColumn]);
  }
  while (unvisitedFrontier.length > 0) {
    var randomIdx = Math.floor(Math.random() * unvisitedFrontier.length);
    var randomFrontierCell = unvisitedFrontier[randomIdx];
    var frontierRow = randomFrontierCell[0];
    var frontierColumn = randomFrontierCell[1];
    if (isBlocked[frontierRow][frontierColumn] && !visited[frontierRow][frontierColumn]) {
      var sourceRow = randomFrontierCell[2];
      var sourceColumn = randomFrontierCell[3];
      var intermediateRow = Math.floor((sourceRow + frontierRow) / 2); // if delta is 0, remains unchaged
      var intermediateColumn = Math.floor((sourceColumn + frontierColumn) / 2); //  if 2, finds middle (intermediate)
      isBlocked[intermediateRow][intermediateColumn] = false;
      visited[intermediateRow][intermediateColumn] = true;
      isBlocked[frontierRow][frontierColumn] = false;
      visited[frontierRow][frontierColumn] = true;
      mazeGenerateMoves.push([intermediateRow, intermediateColumn]);
      mazeGenerateMoves.push([frontierRow, frontierColumn]);
      neighbors = getNeighborCells(frontierRow, frontierColumn, 2); // find new frontier of current frontier
      for (var i = 0; i < neighbors.length; i++) {
        var newFrontierRow = neighbors[i][0];
        var newFrontierColumn = neighbors[i][1];
        if (isBlocked[newFrontierRow][newFrontierColumn] && !visited[newFrontierRow][newFrontierColumn]) {
          unvisitedFrontier.push([newFrontierRow, newFrontierColumn, frontierRow, frontierColumn]);
        }
      }
    }
    unvisitedFrontier.splice(randomIdx, 1);
  }
  if (mode.localeCompare("BFS") == 0) {
    var ret = BFS(startRow, startColumn, endRow, endColumn);
    movesArray = ret[0];
    drawPath = ret[1];
  }
}


if (!autoGeneratedMaze) {
  document.addEventListener("mousedown", e => {
    if (holdingDownMouse) {
      holdingDownMouse = false;
      if (mode.localeCompare("BFS") == 0) {
        var ret = BFS(startRow, startColumn, endRow, endColumn);
        movesArray = ret[0];
        drawPath = ret[1];
        animateBFS();
      }
      if (mode.localeCompare("DFS") == 0) {
        var visited = new Array(gridDimension);
        for (var i = 0; i < gridDimension; i++) {
          visited[i] = new Array(gridDimension);
          for (var j = 0; j < gridDimension; j++) {
            visited[i][j] = false;
          }
        }
        visited[startRow][startColumn] = true;
        var ret = DFS(startRow, startColumn, endRow, endColumn, visited, [], []);
        movesArray = ret[0];
        drawPath = ret[1];
        animateDFS();
      }
    }
    else holdingDownMouse = true;
  });

  document.addEventListener("mousemove", e => {
    if (holdingDownMouse) {
      fillCell(e.clientX, e.clientY, black);
      isBlocked[yPixelToCell(e.clientY)][xPixelToCell(e.clientX)] = true;
    }
  });
}

drawGrid(gridDimension);

fillCell(xCellToPixel(startColumn), yCellToPixel(startRow), green);
fillCell(xCellToPixel(endColumn), yCellToPixel(endRow), red);

animateMazeGenerationAndBFS();

function drawGrid(numLines) {
  for (var i = 1; i <= numLines; i++) {
    c.beginPath();
    var y = verticalSpacing * i;
    var x = horizontalSpacing * i;
    c.moveTo(x, 0);
    c.lineTo(x, innerHeight);
    c.moveTo(0, y);
    c.lineTo(innerWidth, y);
    c.stroke();
    c.closePath();
  }
}

function xCellToPixel(x) {
  return x * horizontalSpacing;
}

function xPixelToCell(x) {
  return Math.floor((x + 1) / horizontalSpacing);
}

function yCellToPixel(y) {
  return y * verticalSpacing;
}

function yPixelToCell(y) {
  return Math.floor((y + 1) / verticalSpacing);
}

function fillCell(xPixel, yPixel, color) {
  c.beginPath();
  if (xPixel == innerWidth) {
    xPixel--;
  }
  if (yPixel == innerHeight) {
    yPixel--;
  }
  var xCell = xPixelToCell(xPixel);
  var yCell = yPixelToCell(yPixel);
  c.fillStyle = color;
  c.fillRect(xCellToPixel(xCell), yCellToPixel(yCell), horizontalSpacing, verticalSpacing);
  c.closePath();
}

function getNeighborCells(row, column, distance) {
  var dx = [distance, distance * -1, 0, 0];
  var dy = [0, 0, distance, distance * -1];
  var neighbors = [];
  for (var i = 0; i < 4; i++) {
    var rowNew = row + dx[i];
    var columnNew = column + dy[i];
    if (rowNew >= 0 && rowNew < gridDimension && columnNew >= 0 && columnNew < gridDimension) {
      neighbors.push([rowNew, columnNew]);
    }
  }
  return neighbors;
}

function BFS(rStart, cStart, rFinish, cFinish) {
  var allSteps = [];
  var visited = new Array(gridDimension);
  for (var i = 0; i < gridDimension; i++) {
    visited[i] = new Array(gridDimension);
    for (var j = 0; j < gridDimension; j++) {
      visited[i][j] = false;
    }
  }
  var dx = [1, -1, 0, 0];
  var dy = [0, 0, 1, -1];
  var q = [];
  q.push([[rStart, cStart], [[1, 1]]]);
  visited[rStart][cStart] = true;
  while (q.length != 0 && !visited[rFinish][cFinish]) {
    var r = q[0][0][0];
    var c = q[0][0][1];
    var path = q[0][1];
    q.shift();
    allSteps.push([r, c]);
    for (var i = 0; i < 4; i++) {
      var rNew = r + dx[i];
      var cNew = c + dy[i];
      if (rNew == rFinish && cNew == cFinish) {
        return [allSteps, path];
      }
      if (rNew >= 0 && rNew < gridDimension && cNew >= 0 && cNew < gridDimension
          && !visited[rNew][cNew] && !isBlocked[rNew][cNew]) {
            var pathNew = path.slice();
            pathNew.push([rNew, cNew]);
            q.push([[rNew, cNew], pathNew]);
            visited[rNew][cNew] = true;
      }
    }
  }
  return [allSteps, [rStart, cStart]];
}

var flagDFS = false;
var finalPathDFS = [];

function DFS(r, c, rFinish, cFinish, visited, listOfMoves, path) {
  if (flagDFS) return;
  listOfMoves.push([r, c]);
  var dx = [1, 0, -1, 0];
  var dy = [0, 1, 0, -1];
  for (var i = 0; i < 4; i++) {
    var rNew = r + dx[i];
    var cNew = c + dy[i];
    if (rNew == rFinish && cNew == cFinish) {
      flagDFS = true;
      finalPathDFS = path;
    }
    if (rNew >= 0 && rNew < gridDimension && cNew >= 0 && cNew < gridDimension
        && !isBlocked[rNew][cNew] && !visited[rNew][cNew]) {
      visited[rNew][cNew] = true;
      var pathNew = path.slice();
      pathNew.push([rNew, cNew]);
      DFS(rNew, cNew, rFinish, cFinish, visited, listOfMoves, pathNew);
    }
  }
  return [listOfMoves, finalPathDFS];
}

var index = 1;

function animateMazeGenerationAndBFS() {
  if (index <= mazeGenerateMoves.length) {
    var move = mazeGenerateMoves[index - 1];
    fillCell(xCellToPixel(move[1]), yCellToPixel(move[0]), white);
    index++;
  }
  else if (index - mazeGenerateMoves.length < movesArray.length) {
    var move = movesArray[index - mazeGenerateMoves.length];
    fillCell(xCellToPixel(move[1]), yCellToPixel(move[0]), blue);
    index++;
  }
  else if (index - mazeGenerateMoves.length == movesArray.length) index++;
  else if (index - mazeGenerateMoves.length > movesArray.length) {
    var indexIntoPath = index - movesArray.length - mazeGenerateMoves.length;
    if (indexIntoPath < drawPath.length) {
      var move = drawPath[indexIntoPath];
      fillCell(xCellToPixel(move[1]), yCellToPixel(move[0]), green);
      index++;
    }
  }
  requestAnimationFrame(animateMazeGenerationAndBFS);
}

function animateBFS() {
  if (index < movesArray.length) {
    var move = movesArray[index];
    fillCell(xCellToPixel(move[1]), yCellToPixel(move[0]), blue); // 1 and 0 are swapped because rows = y, columns = x
    index++;
  }
  if (index == movesArray.length) index++;
  if (index > movesArray.length) {
    var indexIntoPath = index - movesArray.length;
    if (indexIntoPath < drawPath.length) {
      var move = drawPath[indexIntoPath];
      fillCell(xCellToPixel(move[1]), yCellToPixel(move[0]), green);
      index++;
    }
  }
  requestAnimationFrame(animateBFS);
}

function animateDFS() {
  if (index < movesArray.length) {
    var move = movesArray[index];
    fillCell(xCellToPixel(move[1]), yCellToPixel(move[0]), blue);
    index++;
  }
  if (index >= movesArray.length) {
    var indexIntoPath = index - movesArray.length;
    if (indexIntoPath < drawPath.length) {
      var move = drawPath[indexIntoPath];
      fillCell(xCellToPixel(move[1]), yCellToPixel(move[0]), green);
      index++;
    }
  }
  requestAnimationFrame(animateDFS);
}
